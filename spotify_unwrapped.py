#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Author:       Casey Sparks
# Date:         November 23, 2021
# Description:  Creates a playlist of 100 tracks generated by a user's
#               long-term listening trends on Spotify.

import argparse
import csv
import io
import locale
import logging
import random
from pprint import pp
import spotipy

# Set locale.
locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')

# Log to the screen.
handler = logging.StreamHandler()
log = logging.getLogger()

handler.setFormatter(logging.Formatter('%(asctime)s: "%(name)s" (line: %(lineno)d) - %(levelname)s %(message)s'))
log.setLevel(logging.INFO)
log.addHandler(handler)

def get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--csv',
        dest='csv',
        action='store_true',
        help='Output to CSV.'
    )
    parser.add_argument(
        '--uris', '-u',
        dest='uris',
        nargs='+',
        help='The track (or artist) URIs to use as the seed.'
    )
    parser.add_argument(
        '--quiet', '-q',
        dest='quiet',
        action='store_true',
        help='Dry run. Print output to STDOUT without creating a playlist.'
    )
    parser.add_argument(
        '-r', '--rand',
        dest='random',
        action='store_true'
    )
    parser.add_argument( # Seed categories.
        '-s', '--seed',
        dest='seed',
        default=['artists', 'tracks'],
        help='Select seeds (artists or tracks) for recommendations.'
    )
    parser.add_argument(
        '-t', '--range',
        dest='time_range',
        default='long_term',
        help='Select a time range for queries. Must be long_term, mid_term, or short_term.'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_const',
        dest='loglevel',
        const=logging.DEBUG,
        help='Set log level to DEBUG.'
    )

    return parser.parse_args()


def construct_playlist_dict(tracks: list):
    playlist = list()

    for track in tracks:
        song = {
            'title': track['name'],
            'artist': track['artists'][0]['name'],
            'album': track['album']['name'],
            'url': track['external_urls']['spotify'],
            'uri': track['uri']
        }

        playlist.append(song)

    return playlist


def list_to_csv(data: list):
    '''
    Converts a list of dicts to CSV format.
    Dicts must all have the same keys in order for this function to pull the CSV headers.
    '''
    string_fh = io.StringIO()
    writer = csv.DictWriter(string_fh, data[0].keys())

    writer.writeheader()
    writer.writerows(data)

    return string_fh.getvalue()


class Spotify():
    def __init__(self, scope):
        log.debug('Instantiating Spotify client.')

        self.client = spotipy.Spotify(auth_manager=spotipy.oauth2.SpotifyOAuth(scope=scope))
        self.user = self.client.current_user()
        self.playlist = self.return_playlist()


    def return_playlist(self):
        """Create the 'recommendations' playlist if it doesn't exist and select it if it does."""
        log.debug('Populating user playlists.')

        for playlist in self.client.current_user_playlists()['items']:
            if playlist['name'] == 'Recommendations':
                log.debug("Found 'recommendations' playlist.")

                recommendations_playlist = playlist

                break

        else:
            log.debug("Creating 'recommendations playlist.")

            recommendations_playlist = self.client.user_playlist_create(
                self.user['id'],
                'Recommendations',
                description='Procedurally generated playlist of recommended tracks.'
            )

        return recommendations_playlist


    def get_recommendations(self, args, limit: int = 100, country: str = 'US'):
        """Populate artist/track seeds for Spotify's recommendations API."""
        seed_artists = list()
        seed_tracks = list()
        top_artists = list()
        top_tracks = list()

        log.info('Getting track recommendations.')

        if args.uris:
            seed_uris = args.uris
        else:
            if 'artists' in args.seed:
                top_artists = [artist for artist in self.client.current_user_top_artists(
                    time_range=args.time_range
                )['items']]

            if 'tracks' in args.seed:
                top_tracks = [track for track in self.client.current_user_top_tracks(
                    time_range=args.time_range
                )['items']]

            if args.random:
                seed_uris = random.sample([seed['uri'] for seed in top_artists + top_tracks], 5)
            else:
                sorted_seeds = sorted(top_artists + top_tracks, key=lambda d: d['popularity'])
                seed_uris = [seed['uri'] for seed in sorted_seeds[:5]]

        for seed in seed_uris:
            if 'artist' in seed:
                seed_artists.append(seed)
            else:
                seed_tracks.append(seed)

        recommendations = self.client.recommendations(
            seed_artists=seed_artists,
            seed_tracks=seed_tracks,
            limit=limit,
            country=country
        )['tracks']

        log.debug(f'Recommendations: {recommendations}')

        return recommendations


if __name__ == '__main__':
    args = get_arguments()
    scope = 'user-top-read user-read-private user-read-recently-played playlist-modify-private playlist-modify-public'
    spotify = Spotify(scope)
    recommendations = construct_playlist_dict(spotify.get_recommendations(args))
    tracks = [track['uri'] for track in recommendations]

    log.info('Adding recommendations to playlist.')

    if args.csv:
        print(list_to_csv(recommendations))

    if not args.quiet:
        spotify.client.user_playlist_add_tracks(
            spotify.user['id'],
            spotify.playlist['id'],
            tracks
        )
